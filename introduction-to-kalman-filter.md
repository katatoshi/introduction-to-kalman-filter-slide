---
marp: true
paginate: true
theme: default
math: mathjax
style: |
  {
    font-size:26px
  }
  section.centered {
    display: flex;
    justify-content: center;
  }
  section {
    display: flex;
    justify-content: center;
  }
  .blue {
    color: blue;
  }
  .red {
    color: red;
  }
  .green {
    color: green;
  }
---

# カルマンフィルタの紹介

katatoshi

---

## このスライドについて

- カルマンフィルタはロボットの自己位置推定など，時系列データから雑音を取り除くアルゴリズム
- このスライドでは，簡単なロボットのシミュレーションを例に，カルマンフィルタでどういったことができるのかについて紹介する

---

## カルマンフィルタの概要

- カルマンフィルタは時系列データから雑音を取り除くアルゴリズム
  - 時系列データの例: 毎秒のセンサ値のデータ
- カルマンフィルタは「観測されたデータには雑音が含まれており，真の値はその背後に隠れている」という状況に適用できる
  - ロボットが観測した距離データには雑音が含まれており，ロボットの位置 (真の値) はその背後に隠れている
- カルマンフィルタを使うと，観測データから真の値を推定できる

---

## 簡単なロボットの例

- 直線上を移動するロボット
- ロボットは自分の位置は分からないが，目印からの距離を観測できる
- 目印からの距離の観測値には誤差があり，実際の距離からランダムにズレたものになる
- ロボットは移動量を指令として受け取る
- ロボットは指令通り移動しようとするが，路面状況等により，指令からランダムにズレた位置に移動してしまう

---

![bg contain](IMG_9341.jpeg)

---

## 簡単なロボットのシミュレーション

- 簡単なロボットを Python でシミュレーション (simple_robot.py)
- ロボットを `SimpleRobot` クラスで表現
- 現在の位置 `x` と最新の観測値 `y` を属性として持つ
  - 実際には，現在の位置 `x` はロボットにはわからないが，シミュレーションのために `SimpleRobot` クラスに持たせてある

```python
class SimpleRobot

    def __init__(self, x_0: float, S: float, Q: float, R: float):
        self.x = x_0 + rng.normal(0.0, S)
        self.y = 0.0 # まだ何も観測していないということ (0.0 という値に意味はない)
        self.Q = Q
        self.R = R
```

---

## ロボットの初期位置

- ロボットの初期位置は指定値からランダムにズレた位置になるとする
  - 指定された位置に設置しようとしたがズレてしまった等
```python
    def __init__(self, x_0: float, S: float, Q: float, R: float):
        self.x = x_0 + rng.normal(0.0, S)
        self.y = 0.0 # まだ何も観測していないということ (0.0 という値に意味はない)
        self.Q = Q
        self.R = R
```
- `x_0` が指定値
- `rng.normal` で正規分布に従う乱数を生成
  - `rng.normal(0.0, S)` は平均 `0.0`，分散 `S` の正規分布に従う乱数
  - 平均 `0.0` はズレの中心を表している
  - 分散 `S` はズレの大きさを表している

---

## 距離の観測と移動

- 目印からの距離の観測は `observe` メソッドで表現
```python
    def observe(self) -> None:
        v = rng.normal(0.0, self.R)
        self.y = self.x + v
```
- `v` が誤差を表すランダムなズレ
  - コンストラクタで定義していた属性 `R` は `v` の分散
- ロボットの移動は `move` メソッドで表現
```python
    def move(self, u: float) -> None:
        w = rng.normal(0.0, self.Q)
        self.x = self.x + u + w
```
- `u` が指令 (移動量) で `w` がランダムなズレ
  - コンストラクタで定義していた属性 `Q` は `w` の分散

---

## ロボットの動き

- `SimpleRobot` ロボットは，インスタンスが生成されたタイミングで，指定値の周辺に設置される (初期位置)
- インスタンスが生成された後は，`observe` で観測して `move` で移動，という流れを繰り返す
- 設定されたゴールを超えたならシミュレーションを終了する

---

## シミュレーションの流れ

```python
# x_0=0.0, S=0.5 で，初期位置は 0.0 周辺であることを表す
# Q=0.5, R=2.0 で，移動時のズレに比べて，観測値の誤差が大きいことを表す
simple_robot = SimpleRobot(x_0=0.0, S=0.5, Q=0.5, R=2.0)
goal = 30.0 # ループを抜けるためにゴールを設定
while True:
    # ここが移動後のタイミング (初回は初期位置に設置されたタイミング)
    x = simple_robot.x # ロボットの位置
    simple_robot.observe() # 距離を観測させる
    y = simple_robot.y # 距離の観測値
    if y >= goal: # 実際には，ロボットには真の位置が分からないので，観測値でゴールに到達したか判断
        break # ゴールを超えているなら終わり

    u = 1.0 # 1.0 移動せよという指令
    simple_robot.move(1.0) # 指令を渡して移動させる
```

---

## シミュレーションの実行

- simple_robot.py を実行した画面を参照

---

## シミュレーションの結果

- 「<span class="blue">●︎</span>」(実線) がロボットの位置 `x`
- 「<span class="red">×</span>」(破線) が距離の観測値 `y`

![bg contain right:50%](self-localization/simple-robot/state_and_observation.png)

---

## 距離の観測値のみの結果

- 今回はシミュレーションなのでロボットの位置がわかっているが，実際に利用できるのは距離の観測値のみ 
- ロボットの位置は距離の観測値から推定するしかない

![bg contain right:50%](self-localization/simple-robot/only_observation.png)

---

## カルマンフィルタで観測値から位置を推定する

- 先ほどの例でカルマンフィルタを使って，距離の観測値からロボットの位置を推定 (kalman_filter.py)
- コードの説明は後にして，まずは実行してみる

---

## カルマンフィルタの結果

- 「<span class="blue">●</span>」(実線) がロボットの位置
- 「<span class="red">×</span>」(破線) が距離の観測値
- 「<span class="green">♦︎</span>」(鎖線) がカルマンフィルタの推定値

![bg contain right:50%](self-localization/kalman-filter/state_observation_and_filtering.png)

---

## ロボットの位置と推定値

- カルマンフィルタの推定値はロボットの位置をよく再現している
- カルマンフィルタの推定値の計算には，ロボットの位置はまったく使用していない，ということがポイント

![bg contain right:50%](self-localization/kalman-filter/state_and_filtering.png)

---

## 距離の観測値と推定値

- カルマンフィルタの推定値は観測値のブレを押さえたような動きをしている

![bg contain right:50%](self-localization/kalman-filter/observation_and_filtering.png)

---

## カルマンフィルタのアルゴリズムの前に

- カルマンフィルタが適用できる状態のおさらい
- カルマンフィルタは「観測されたデータには雑音が含まれており，真の値はその背後に隠れている」という状況に適用できる

---

## カルマンフィルタが適用できる状況

- もう少し詳しくいうと，次のような状況
- 観測値 $y$ は真の値 $x$ に誤差 (ズレ) $v$ を加えた値である:
$$
y = x + v
$$
- 真の値 $x$ は指令 $u$ とズレ $w$ を加えた値 $x'$ に推移する:
$$
x' = x + u + w
$$
- 真の値の初期値は指定値にズレを加えた値である
- ちょうど，簡単なロボットの例と同じ状況
  - そうなるように簡単なロボットの例を作った
  - 実際には，解決したい問題をどうやって，このような状況に落とし込むのか (そもそも落とし込めるのか) 考える必要がある
- カルマンフィルタはこのような状況を前提としたアルゴリズム

---

## カルマンフィルタのアルゴリズム

- カルマンフィルタを `KalmanFilter` クラスで実装
- 予測推定値 `x_p` とフィルタリング推定値 `x_f` を属性として持つ
  - 予測推定誤差の分散 `P_p` とフィルタリング推定誤差の分散 `P_f` も属性として持つ
  - これまでカルマンフィルタの推定値と呼んでいたものは，フィルタリング推定値
```python
class KalmanFilter:

    def __init__(self, x_0: float, S: float, Q: float, R: float):
        self.x_p = x_0
        self.P_p = S
        self.x_f = 0.0 # まだ何もフィルタリングしていないということ (0.0 という値に意味はない)
        self.P_p = 0.0 # まだ何もフィルタリングしていないということ (0.0 という値に意味はない)
        self.Q = Q
        self.R = R
```
- カルマンフィルタは予測推定値 `x_p` (及び `P_p`) とフィルタリング推定値 `x_f` (及び `P_f`) を交互に更新するアルゴリズム

---

## 予測推定値の初期値

- アルゴリズムの最初のステップでは，予測推定値 `x_p` (及び `P_p`) の初期値を設定する
- この時点では，真の値の初期値は指定値からランダムにズレた値になることしか分からないので，この指定値を予測推定値の初期値とする
  - 予測推定誤差 `P_p` の初期値は，指定値からのズレの分散とする
  - まだ何も観測していないときに，次の真の値を予測 (prediction) している
```python
    def __init__(self, x_0: float, S: float, Q: float, R: float):
        self.x_p = x_0
        self.P_p = S
        self.x_f = 0.0 # まだ何もフィルタリングしていないということ (0.0 という値に意味はない)
        self.P_p = 0.0 # まだ何もフィルタリングしていないということ (0.0 という値に意味はない)
        self.Q = Q
        self.R = R
```
- なお，`Q` と `R` は簡単なロボットの例同様，観測誤差と指令からのズレの分散

---

## フィルタリング推定値の更新

- 観測値 `y` が得られたら，`filter` メソッドでフィルタリング推定値を更新
```python
    def filter(self, y: float) -> None:
        K = self.P_p / (self.P_p + self.R) # カルマンゲイン
        self.x_f = self.x_p + K * (y - self.x_p)
        self.P_f = self.P_p - K * self.P_p
```
- 現在までの観測値を使って，現在の真の値を推定することをフィルタリング (filtering) という
  - 現在の観測値 `y` しか使っていないように見えるが，予測推定値 `x_p` にこれまでの観測値が反映されている
- `K` はカルマンゲインと呼ばれるもので，観測値と予測推定値の差 (予測誤差) `y - x_p` を `K` 倍すると，フィルタリング推定値と予測推定値の差 `x_f - x_p` になる
  - 信号処理等の知識がないので間違っているかもしれないが，`K` は入力 `y - x_p` と出力 `x_f - x_p` の比なので，確かに「ゲイン」を表していると言えるはず

---

## 予測推定値の更新

- 指令 `u` を受け取ったら，`predict` メソッドで予測推定値を更新
```python
    def predict(self, u: float) -> None:
        self.x_p = self.x_f + u
        self.P_p = self.P_f + self.Q
```
- 現在までの観測値を使って，次の真の値を推定しているので予測 (prediction) という
- 真の値は $x' = x + u + w$ で推移する状況を前提としているので，ズレ $w$ は平均的には $0$ なら，次の真の値は $x + u$ が一番ありそうだと推測できる
- 現在の真の値 $x$ は実際には分からないので，これまでの情報を最も反映している，フィルタリング推定値を代わりに使い，`x_f + u` を予測推定値とする，と解釈できる
  - 予測推定誤差の分散 `P_p` も同じように考えることができる
    - $x$ と $w$ が独立なら $x + u + w$ の分散 $P_p$ は $x$ の分散 $P_f$ と $w$ の分散 $Q$ の和なので $P_p = P_f + Q$ となる．$u$ はランダムではないので分散には現れない
- 予測推定値は真の値の推移法則を利用して，次の真の値を予測しているといえる

---

## カルマンフィルタの流れ

- `KalmanFilter` は，対象とする状況に対応するように，同じパラメータ (初期の真の値の設定値と各種ズレの分散) で初期化する
- 初期化された後は，観測値が得られたら `filter` でフィルタリング推定値を更新，指令を受け取ったら `predict` で予測推定値を更新，という流れを繰り返す

---

## 簡単なロボットの例でのカルマンフィルタ
```python
simple_robot = SimpleRobot(x_0=0.0, S=0.5, Q=0.5, R=2.0)
# simple_robot と同じパラメータを渡して，simple_robot に対応するカルマンフィルタを作る
kalman_filter = KalmanFilter(x_0=0.0, S=0.5, Q=0.5, R=2.0)
goal = 30.0
while True:
    x = simple_robot.x
    # x_p = kalman_filter.x_p # ロボットの位置の予測推定値 (ここでは使わない)
    simple_robot.observe()
    y = simple_robot.y
    kalman_filter.filter(y) # 観測値を使ってフィルタリング推定値を更新
    x_f = kalman_filter.x_f # ロボットの位置のフィルタリング推定値
    if y >= goal:
        break

    u = 1.0
    simple_robot.move(u)
    kalman_filter.predict(u) # 指令を渡して予測推定値を更新
```

---

## 補足: フィルタリング推定値の更新でやっていること

```python
    def filter(self, y: float) -> None:
        K = self.P_p / (self.P_p + self.R) # カルマンゲイン
        self.x_f = self.x_p + K * (y - self.x_p)
        self.P_f = self.P_p - K * self.P_p
```
- カルマンゲインを変形すると `K = 1 / (1 + R / P_p)`
- 観測誤差 `R` の方が予測誤差 `P_p` より大きくなる [小さくなる] ほど，カルマンゲイン `K` は小さくなる [大きくなる] (`K` の範囲は `0.0` 以上 `1.0` 以下)
- フィルタリング推定値を変形すると `x_f = K * y + (1 - K) * x_p`
- カルマンゲイン `K` が小さくなる [大きくなる] ほど，予測推定値 `x_p` [観測値 `y`] の割合が増える
- るまり，観測誤差 `R` と予測誤差 `P_p` を比較して，誤差の小さい方の割合が大きくなるように加重平均をとって，推定値を更新しているのがフィルタリング推定値
  - カルマンゲインは新しい情報である `y` をどれくらい取り入れるかの割合ともいえる
- フィルタリング誤差も同様に考えることができるが省略

---

## 発展的な話題

- 予測推定値とフィルタリング推定値の更新でやっていることについて説明したが，あの更新式でうまく推定できることの裏付けは，数学的により厳密に説明できる
  - 元々，そっちが気になって勉強していた
- このスライドで「カルマンフィルタが適用できる状況」，「真の値」と呼んでいたものは，一般的には「状態空間モデル」，「状態」とそれぞれ呼ばれる
- 今回，$y = x + v, x' = x + u + w$ という状況を考えたが，より一般に，$F, G, H$ を定数として，$y = H x + v, x' = F x + u + G w$ といった状況もカルマンフィルタで扱える
- 今回は1次元のケースを扱ったが，多次元のケースも扱える (むしろほとんどの場合そう)

---

## カルマンフィルタの限界

- カルマンフィルタは $y = H x + v, x' = F x + u + G w$ という状況にも適用できると述べたが，さらに一般化して，$h$, $f$ を関数として，$y = h(x) + v, x' = f(x, u) + G w$ という状況を考えると，一般に，これはカルマンフィルタでは扱うことができるとは限らない
  - 例えば，$y = x^2 + v, x' = \sin(x) + w$ という状況は扱えない
- こういった状況には，拡張カルマンフィルタやパーティクルフィルタといった，近似的な手法を適用することができる
  - 平面を動くロボットを考えると，こういった状況をなってしまうため，必然的に，拡張カルマンフィルタやパーティクルフィルタなどの手法を使う必要がある
  - 拡張カルマンフィルタとパーティクルフィルタについても勉強したので機会があれば説明したい

---

## まとめ

- カルマンフィルタが適用できる状況では，カルマンフィルタを使うことで，雑音を含む観測値から真の値を推定することができる
- カルマンフィルタでは予測推定値とフィルタリング推定値の2つの推定値を交互に更新することで，真の値を推定している
- 予測推定値は真の値の推移法則を利用して，次の真の値を推定している
- フィルタリング推定値は前回の予測推定値という今ある情報と，観測値という新しく得られた情報を，その信頼度に応じた割合で取り込むことで，現在の真の値を推定している
- カルマンフィルタは係数が1でないケースや多次元のケースにも適用できる
- カルマンフィルタが適用できないような状況もあるが，そのような状況には，拡張カルマンフィルタやパーティクルフィルタといった手法が適用できる

---

## 参考文献

- 足立 修一，丸田 一郎『カルマンフィルタの基礎』東京電機大学出版局，2012
- 上田 隆一『詳解 確率ロボティクス Pythonによる基礎アルゴリズムの実装』講談社，2019
- 片山 徹『非線形カルマンフィルタ』朝倉書店，2011
- 片山 徹「非線形カルマンフィルタの基礎」計測と制御，2017年56巻9号 p.638-643
  - https://www.jstage.jst.go.jp/article/sicejl/56/9/56_638/_pdf/-char/ja (pdf)
- 野村 俊一『カルマンフィルタ―Rを使った時系列予測と状態空間モデル―』共立出版，2016
